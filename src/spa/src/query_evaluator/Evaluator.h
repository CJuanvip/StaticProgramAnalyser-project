#pragma once

#include <string>
#include <vector>
#include <memory>
#include <unordered_map>
#include <list>
#include "pkb/PKBTableManager.h"
#include "ResultTable.h"
#include "TableCacher.h"
#include "parser/AST.h"
#include "Relation.h"
#include "Clause.h"
#include "utils/UnionFindDisjointSet.h"

namespace std {
  template<>
    class hash<common::AttrRef> {
      public:
        size_t operator() (const common::AttrRef &attrRef) const {
          size_t seed = 0;
          seed ^= hash<string>()(attrRef.synonym) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
          seed ^= hash<std::optional<common::AttrNameId>>()(attrRef.attribute) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
          return seed;
        }
    };
};

namespace query_eval {
  using namespace common;

  class Evaluator {
  public:
    Evaluator(TableCacher &cache):
      cache_(cache) { };
    ~Evaluator(){};

    /**
     * Processes a single PQL query, in AST format.
     */
    std::list<std::string> evaluate(const Query &query);


    /**
     * =================================================================
     * Stage 1: PQL validation
     * This stage checks for semantic errors in the PQL query.
     * If semantic errors are detected,
     * the query processing is terminated immediately.
     * =================================================================
     */
    /**
     * Used in Stage 1: PQL validation
     * Returns true if the query object has semantic errors. (As per iteration 1)
     */
    bool hasSemanticError(const Query& query) const;

  private:
    /**
     *  Const reference to the TableCacher which the Evaluator will be retrieving information from
     */
    TableCacher& cache_;

     /**
     * Global stop boolean.
     * When set to true, the PQL query yields no result and the query processing
     * can be terminated prematurely.
     */
    bool hasResult_ = false;


    /**
     * =================================================================
     * Stage 2: Synonym Normalization
     * This stage converts synonyms and (integer and string) constants
     * to an internally assigned integer identifier.
     * This is to improve the performance of `Evaluator` as it avoids
     * string comparisons in subsequent steps.
     * =================================================================
     */

    /**
     * Stores the mapping between synonym string and the synonym index.
     */
    std::unordered_map<AttrRef, SchemaType> synonymToIndex_;

    /**
     * Stores which type each synonym is.
     * entityType_[synonymIndex] = type of synonym
     */
    std::vector<EntityId> entityType_;

    /**
     * Stores the normalized synonymIds of the requested results.
     */
    std::vector<SchemaType> resultList_;

    /**
     * Helper classes to map a given synonym string to its synonymIndex
     */
    std::optional<SchemaType> getSynonymIndex(const AttrRef &synonym) const;
    std::optional<SchemaType> getSynonymIndex(const Synonym &synonym) const;

    /**
     * Helper class to normalize one particular AttrRef
     */
    SchemaType normalizeAttrRef(const AttrRef &attrRef);

    /**
     * Normalizes declarations in the query.
     * Assigns synonymId to each synonym that is declared.
     * Returns true if all declarations are successfully normalized.
     */
    bool normalizeDeclarations(const std::vector<Declaration> &declarations);

    /**
     * Normalizes the list of result variables in the query.
     * Retrieves the synonymId for each synonym that is declared.
     * Returns true if all result variables are successfully normalized.
     */
    bool normalizeResultList(const std::vector<AttrRef> &resultList);

    /**
     * Normalizes the list of with variables in the query.
     * Retrieves the synonymId for each synonym that is declared.
     * Returns true if all result variables are successfully normalized.
     */
    bool normalizeWithAttributes(const std::vector<With> &withList);

    /**
     * =================================================================
     * Stage 3: Early termination
     * This stage checks if the PQL is of a form that guarantees that
     * there will be no result.
     * =================================================================
     */

    /**
     * Returns true if the PQL will definitely have no result.
     */

    bool canEarlyTerminate(const Query &query) const;

    /**
     * =================================================================
     * Stage 4: Clause Evaluation
     * This stage processes every such that, pattern and with clause
     * in the query and enforces their constraints.
     * =================================================================
     */

    /**
     * Stores the ResultTables generated by the clauses that should be joined later.
     */
    std::vector<ResultTable> clauseTables_;
    std::vector<SuchThatClause> booleanSuchThats_, oneSynonymSuchThats_, twoSynonymSuchThats_;

    /**
     * Loops through the list of such that clauses and delegates the processing to
     * one of the handler methods below.
     */
    void sortSuchThats(const std::vector<SuchThat> &suchThats);
    /**
     * Computes the result for such that clauses that will evaluate to a boolean True/False.
     * Returns True/False depending on the result of the clause.
     */
    bool processBooleanSuchThat(const SuchThatClause &clause);
    /**
     * Generates clause tables that will enforce the constraint of this clause on a single synonym.
     * Returns false if the table generated is already empty -> definitely no result.
     */
    bool processOneSynonymSuchThat(const SuchThatClause &clause);
    /**
     * Generates clause tables that will enforce the constraints of this clause on two synonyms.
     * Returns false if the table generated is already empty -> definitely no result.
     */
    bool processTwoSynonymSuchThat(const SuchThatClause &clause);


    /**
     * Loops through the list of Pattern and delegates the processing to one of the handler methods below.
     */
    void sortPatterns(const std::vector<Pattern> &patterns);
    /**
     * Generates clause tables that will enforce the constraints of assign pattern.
     * Returns false if it can be ascertained that there will be no result for this clause.
     */
    bool processAssignPattern(const BinaryPattern &pattern);
    /**
     * Generates clause tables that will enforce the constraints of if pattern.
     * Returns false if it can be ascertained that there will be no result for this clause.
     */
    bool processIfPattern(const TernaryPattern &pattern);
    /**
     * Generates clause tables that will enforce the constraints of while pattern.
     * Returns false if it can be ascertained that there will be no result for this clause.
     */
    bool processWhilePattern(const BinaryPattern &pattern);

    std::vector<With> booleanWiths_, oneSynonymWiths_, twoSynonymWiths_;
    /**
     * Loops through the list of With and sorts with clauses according to the number of synonyms they refer to.
     */
    void sortWiths(const std::vector<With> &withs);

    /**
     * Computes the result of the with clause that will evaluate to a boolean value of True/False.
     * Returns True/False depending on the result of the clause.
     */
    bool processBooleanWith(const With &with);
    /**
     * Generates clause tables that will enforce the constraint of this With on a single synonym.
     * Returns false if the table generated is already empty -> definitely no result.
     */
    bool processOneSynonymWith(const With &with);
    /**
     * Generates clause tables that will enforce the constraints of this With on two synonyms.
     * Returns false if the table generated is already empty -> definitely no result.
     */
    bool processTwoSynonymWith(const With &with);

    std::unordered_map<SchemaType, CellType> synonymPredetermined_;
    bool predetermineSynonym(const SchemaType &synonymIndex, const CellType &value);

    bool processBoolean();

    bool processOneSynonym();

    bool processTwoSynonym();

    /**
     * =================================================================
     * Stage 4: Result Generation
     * This stage compiles the ResultTables generated in the previous stage and
     * decides how best to generate the required result.
     * =================================================================
     */
    /**
     * Stores the ResultTables generated by the joining groups of ResultTables.
     */
    std::vector<ResultTable> groupResults_;

    /**
     * Groups the synonym and clause tables into various distinct groups.
     * Calls the below two functions to evaluate them separately, depending on the requirements.
     */
    void generateResultTables();

    /**
     * Given a list of ResultTables, this method return True if the natural join contains at least one row.
     * Currently, this method still computes the natural join of all the tables.
     * This can be further optimized in iteration 3 using a piplined join algorithm.
     */
    bool joinAndCheckResultExist(const std::vector<std::reference_wrapper<const ResultTable>> &tableList) const;

    /**
     * Given a list of ResultTables, this method returns the natural join of all the tables.
     * Currently, the order to join is not optimized.
     * This can be improved in iteration 3 using database optimization algorithms (DP/Greedy).
     */
    ResultTable joinTables(
      std::vector<std::reference_wrapper<const ResultTable>> tableList,
      const std::vector<SchemaType> &requiredSchema
    ) const;

    /**
     * This method takes the result from 'generateResultTables' and formats it into the format required by autotester.
     */
    std::list<std::string> generateFinalResults() const;

    // template<typename ...Args>
    // bool emplaceTable(Args&&... args);
    // Helper function to add one table to the list of tables
    // Also performs the following checks
    // - Returns false if table is empty
    // - Checks for and performs synonym pre-determination
    template<typename ...Args>
    bool emplaceTable(Args&&... args) {
      const ResultTable &table = clauseTables_.emplace_back(
        std::forward<Args>(args)...
      );
      switch (table.size()) {
        case 0:
          hasResult_ = false;
          return false;
        case 1:
          for (size_t i = 0; i < table.schema().size(); ++i) {
            if (!predetermineSynonym(table.schema()[i], table.data()[0][i])) {
              hasResult_ = false;
              return false;
            }
          }
          break;
        default:
          break;
      }
      return true;
    }
  };
}
